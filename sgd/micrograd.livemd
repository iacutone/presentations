# micrograd

```elixir
Mix.install([
  :dg,
  {:kino_vega_lite, "~> 0.1.9"},
  {:vega_lite, "~> 0.1.6"}
])
```

## Section

```elixir
defmodule Value do
  @moduledoc "stores a single scalar value and its gradient"
  defstruct data: nil,
            grad: 0,
            label: "",
            _backward: nil,
            _op: "",
            _prev: []

  @type t :: %Value{
          data: nil | Integer.t(),
          grad: Integer.t(),
          label: String.t(),
          _backward: fun(any),
          _op: String.t(),
          _prev: [%Value{}]
        }

  def add(%Value{} = left, %Value{} = right, label: label) do
    out = %Value{
      data: left.data + right.data,
      _prev: previous(left, right),
      _op: "+",
      label: label
    }

    backward = fn node ->
      left = %Value{left | grad: left.grad + node.grad}
      right = %Value{right | grad: right.grad + node.grad}
      %Value{node | _prev: previous(left, right)}
    end

    %Value{out | _backward: backward}
  end

  def mult(%Value{} = left, %Value{} = right, label: label) do
    out = %Value{
      data: left.data * right.data,
      _prev: previous(left, right),
      _op: "*",
      label: label
    }

    backward = fn node ->
      left = %Value{left | grad: right.data * node.grad}
      right = %Value{right | grad: left.data * node.grad}
      %Value{node | _prev: previous(left, right)}
    end

    %Value{out | _backward: backward}
  end

  def previous(left, right) do
    [left, right]
  end

  def backward(root) do
    gradients = recurse_backward(root, 0, %{})

    gradients
    |> Enum.reduce(root, fn {label, gradient}, acc ->
      update_node(acc, label, gradient)
    end)
  end

  def update_node(
        %Value{
          data: data,
          grad: _grad,
          label: label,
          _backward: backward,
          _op: op,
          _prev: prev
        },
        label,
        new_value
      ) do
    %Value{
      data: data,
      grad: new_value,
      label: label,
      _backward: backward,
      _op: op,
      _prev: prev
    }
  end

  def update_node(%Value{_prev: []} = root, _value, _new_value) do
    root
  end

  def update_node(
        %Value{
          data: data,
          grad: grad,
          label: label,
          _backward: backward,
          _op: op,
          _prev: prev
        },
        other_label,
        new_value
      ) do
    updated_children =
      Enum.map(prev, fn child ->
        update_node(child, other_label, new_value)
      end)

    %Value{
      data: data,
      grad: grad,
      label: label,
      _backward: backward,
      _op: op,
      _prev: updated_children
    }
  end

  def recurse_backward(node, count, counted) do
    next =
      if count == 0 do
        # when last node, set grad to 1 for backprop
        %Value{node | grad: 1}
      else
        node
      end

    if next && next._backward do
      next = next._backward.(next)

      Enum.reduce(next._prev, counted, fn
        %{_prev: [_left | _right]} = child, counted ->
          counted = Map.put(counted, child.label, child.grad)

          if child._op != "" do
            # if there is a child node to recurse on
            recurse_backward(child, count + 1, counted)
          end

        child, counted ->
          Map.put(counted, child.label, child.grad)
      end)
    end
  end
end
```

```elixir
a = %Value{data: 2, label: "a"}
b = %Value{data: -3, label: "b"}
c = %Value{data: 10, label: "c"}
d = Value.mult(a, b, label: "e") |> Value.add(c, label: "d")
```

```elixir
defmodule Graph do
  def draw_dot(root) do
    dot = DG.new()
    build_dot(root, dot, %{count: 0, ops: [], rids: []})

    dot
  end

  def build_dot(node, dot, visited) do
    label = "#{node.label} -> data #{node.data} -> grad #{node.grad}"
    rid = to_string(:rand.uniform(1000))

    DG.add_vertex(dot, node.label, label)

    count = Map.get(visited, :count)
    ops = Map.get(visited, :ops)
    rids = Map.get(visited, :rids)
    val = [node._op]
    visited = %{count: count + 1, ops: ops ++ val, rids: rids ++ [rid]}

    if node._op != "" do
      # create left _op vertex and connect to right edge
      DG.add_vertex(dot, "#{node._op}" <> rid, node._op)
      DG.add_edge(dot, "#{node._op}" <> rid, node.label)
    end

    if count != 0 do
      # if not root node, create edge between vertex and _op
      ops = Map.get(visited, :ops)
      op = Enum.at(ops, count - 1)
      rid = Enum.at(rids, count - 1)
      DG.add_edge(dot, node.label, op <> rid)
    end

    Enum.map(node._prev, fn child ->
      build_dot(child, dot, visited)
    end)
  end
end
```

```elixir
d
|> Value.backward()
|> Map.from_struct()
|> Graph.draw_dot()
```

```mermaid
graph LR
    b[b -> data -3 -> grad -3]-->*238[*]
    +507[+]-->d[d -> data 4 -> grad 1]
    e[e -> data -6 -> grad 1]-->+507[+]
    c[c -> data 10 -> grad 1]-->+507[+]
    a[a -> data 2 -> grad -2]-->*238[*]
    *238[*]-->e[e -> data -6 -> grad 1]


```

```elixir
a = %Value{data: 2, label: "a"}
b = %Value{data: -3, label: "b"}
c = %Value{data: 10, label: "c"}
e = Value.mult(a, b, label: "e")
d = Value.add(e, c, label: "d")
f = %Value{data: -2, label: "f"}
l = Value.mult(d, f, label: "L")

l
|> Value.backward()
|> Map.from_struct()
|> Graph.draw_dot()
```

```mermaid
graph LR
    f[f -> data -2 -> grad 4]-->*427[*]
    b[b -> data -3 -> grad -4]-->*477[*]
    +548[+]-->d[d -> data 4 -> grad -2]
    *477[*]-->e[e -> data -6 -> grad -2]
    *427[*]-->L[L -> data -8 -> grad 0]
    e[e -> data -6 -> grad -2]-->+548[+]
    c[c -> data 10 -> grad -2]-->+548[+]
    a[a -> data 2 -> grad 6]-->*477[*]
    d[d -> data 4 -> grad -2]-->*427[*]
```
